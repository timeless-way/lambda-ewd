Notes (on Structured Programming?)

2018-03-03T12:22 

A Program consists of a source text and a Language in which the source is written. The source text is usually supplied as a file, but it is entirely read in memory before any processing begins.

A Language consists of its syntax and semantics. (Currently there is no semantics yet, working on that.) The syntax is provided as a parser instance. This instance contains a method parse that creates an AST for the source.

Parser instances are created using tatsu (FKA grako) in one of two possible ways. Both ways use the same syntax specification ewd.tatsu. The method Language.__init__ is adapted to both techniques.

The first technique creates a tatsu model in runtime. This is very useful for quick experiments with the grammar. Create a language using

ewd = Language(grammar_file='ewd')

The Language constructor will generate a tatsu model that is
subsequently used to parse sources.

The second technique offers more flexibility at the cost of a more complex build structure.

First, generate a python module for the grammar:
hvtools.generate_python_module('ewd');

Import this module in ewd.py (the module is called ewd_parser). ewd_parser contains a class EwdParser. Create an instance of this class and pass it to the Language constructor:

parser = ewd_parser.EwdParser()

Pass this instance to the Language constructor:

ewd = Language(parser_instance = parser)

NOTE: Language(...) has two paramaters of which EXACTLY ONE must be specified: either use Language(parser_instance=...) or Language(grammar_file=...).

NOTE (2018-06-16): In order for this to work, the start rule of the grammer _must_ be called start. Although there are several ways tot specify another start rule in Tatsu, none of these seemed to work. This might be a bug in Tatsu. However, the workaround is easy, just declare a rule "start = c_program $" and change to "c_program = c_combinator_list" (without the $) and you're done.

2018-04-17T23:00

The Core grammer had to be modified in three dfferent ways to make it compatible with tatsu PEG requirements:

1. The Lester grammar as given in Lester is ambiguous, as the semi-colon in the rule 
alts -> alt1 ';' ... ';' altn
is indistinguishable from the one between super combinators:
program -> sc1 ';' ... ';' scn

This anbiguity can besolved in various ways, I have chosen to modufy the lexical structure by repalcing the semicolon between alterbatives by the Dijkstra block '[]'.

2. The Lester grammar is incomplete as it only specifies the precedence of infix operators in a table. This precedence structure has to be expanded into the grammar rules, giving rise to no less than 8 additional rules.

3. Tatsu specifies semantic functions on a per-rule base, and not on a per-alternative base. In order to define semantics at an appropriate level, many rules of the form
lhs -> rhs-expansion-1 | rhs-expansion-2 | rhs-expansion-3, 
where each expansion is a sequence of (non)terminals must be rewritten into the following form:

lhs -> nonterminal-1 | nonterminal-2 | nonterminal-3;
nonterminal-1 = rhs-expansion-1;
nonterminal-2 = rhs-expansion-2;
nonterminal-3 = rhs-expansion-3;

where each nonterminal-i is a new nonterminal, not occuring in the original grammar.